<!-- 进程（进行中的程序）： -->
1. cpu分配资源的最小单位，是拥有资源和独立运行的最小单位。 代表cpu所能处理的单个任务（可以理解为：cpu是一个工厂，进程就是工厂里的车间）
2. 进程之间相互独立。
3. cpu资源有限，进程越多，电脑越卡。在任意时刻，cpu总是运行一个进程，其他进程处于非运行状态。cpu使用时间片轮转进度算法来实现运行多个进程。

<!-- 线程： -->
1. cpu调度的最小单位，是建立在进程基础上的一次程序运行单位（cpu是工厂，线程就是工人）
2. 一个进程可以有多个线程

一个进程中只有一个执行流称为单线程，即程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行。
一个进程中有多个执行流称为多线程，即在一个程序中可以同时运行多个不同的程序来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。

单线程与多线程，都是指在一个进程内的单和多。不同进程之间也可以通信，不过代价很大。- 调度和切换：线程上下文切换比进程上下文切换要快得多

<!-- 浏览器的进程： -->
1. 主进程：浏览器的主进程负责协调，控制其他子进程 tab（负责各个页面的管理，创建和销毁其他进程）；浏览器界面显示，用户交互，前进，后退，收藏；将渲染(Renderer)进程得到的内存中的Bitmap(位图)，绘制到用户界面上；处理一些不可见的操作，比如网络资源的管理（网络请求），下载，文件访问等。

2. 第三方插件进程： 就是每种类型的插件对应一个进程，仅当使用该插件时才创建GPU进程
3. GPU进程： 该进程也只有一个，用于3D绘制等等
4. 渲染进程，即通常所说的浏览器内核(Renderer进程，内部是多线程)： 负责页面渲染，脚本执行，事件处理等；每个Tab页面都有一个渲染进程，互不影响。浏览器内核（渲染进程），对于渲染进程来说，它当然也是多线程的了

<!-- 渲染进程： -->
1. GUI渲染线程： 负责渲染页面，布局和绘制；页面需要重绘和回流时，该线程就会执行；与js引擎线程互斥，防止渲染结果不可预期。
    详细描述： 
        负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等；解析HTML代码（HTML代码本质是字符串）转化为浏览器认识的节点，生成DOM树，也就是DOM Tree；解析CSS，生成CSSOM（CSS规则树）；把DOM Tree和CSSOM结合，生成Rendering Tree（渲染树）；当我们修改了一些元素的颜色或者背景色，页面就会重绘（Repaint）；当我们修改元素的尺寸，页面就会回流（Reflow)；当页面需要Repainting和Reflow时，GUI线程执行，绘制页面；回流（Reflow）比重绘（Repaint）的成本要高，我们要尽量避免Reflow和Repaint；GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时，GUI线程会被挂起（想当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。
2.  JS引擎线程： 负责处理解析和执行JavaScript脚本程序；只有一个JS引擎线程（单线程）；与GUI渲染线程互斥，防止渲染结果不可预期。
    详细描述： 
        JS引擎线程就是JS内核，负责处理JavaScript脚本程序（例如V8引擎），JS引擎线程负责解析JavaScript脚本，允许代码；JS引擎一直等待任务队列中任务的到来，然后加以处理；浏览器同时只能有一个JS引擎线程在运行JS程序，所以JS是单线程运行的；一个Tab页面（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序；GUI渲染线程与JS引擎线程是互斥的，JS引擎线程会阻塞GUI渲染线程，就是我们常遇到的JS执行时间过长，造成页面的渲染不连贯，导致页面渲染加载阻塞（就是加载慢）。
        例如浏览器渲染的时候遇到 script 标签，就会停止GUI的渲染，然后JS引擎线程开始工作，执行里面的JS代码，等JS执行完毕，JS引擎线程停止工作，GUI继续渲染下面的内容。所以如果JS执行时间太长就会造成页面卡顿的情况。
3.  事件触发线程： 用来控制事件循环（鼠标点击，setTimeout，ajax等）；当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中
    详细描述：
        属于浏览器而不是JS引擎，用来控制事件循环，并且管理着一个事件队列（task queue）；当JS执行碰到事件绑定和一些异步操作（如setTimeout，也可来自浏览器内核的其他线程，如鼠标点击，AJAX异步请求等），会走事件触发线程将对应的事件添加到对应的线程中（比如定时器操作，便把定时器事件添加到定时器线程），等异步事件有了结果，便把他们的回调操作添加到事件队列，等待JS引擎线程空闲时来处理。
        当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。因为JS是单线程，所以这些待处理队列中的事件都得排队等待JS引擎处理。
4.  定时触发器线程： setTnterval与setTimeout所在的线程；定时任务并不是由JS引擎计时的，是由定时触发线程来计时的，计时完毕后，通知事件触发线程。
    详细描述： 
        setInterval与setTimeout所在线程，浏览器定时计数器并不是由JavaScript引擎计数得（因为JavaScript引擎是单线程的，如果处于阻塞线程状态就会影响计数器的准确）；通过单独线程来计时并触发定时（计时完毕后，添加到事件触发线程的事件队列中，等待JS引擎空闲后执行），这个线程就是定时触发器线程，也叫定时器线程
        W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms
5.  异步http请求线程： 浏览器有一个单独的线程用于处理AJAX请求，即用于异步http请求，当请求完成时，若有回调函数，通知事件触发线程。
    详细描述： 
        在XMLHttpRequest连接后是通过浏览器新开一个线程请求，在检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中再由JavaScript引擎执行。
        简单地说，就是当执行到一个http异步请求时，就把异步请求事件添加到异步http请求线程，等收到响应（准确来说应该是http状态变化），再把回调函数添加到事件队列，等待JS引擎线程来执行。


<!-- 事件循环（event loop）: -->
同步任务都在主线程（这里的主线程就是JS引擎线程）上执行，会形成一个执行栈，主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放入一个事件回调。
一旦执行栈中的所有同步任务执行完毕（也就是JS引擎线程空闲了），系统就会读取任务队列，将可运行的异步任务（任务队列中的事件回调，只要任务队列中有事件回调，就说明可以执行）添加到执行栈中，开始执行。

<!-- 微任务和宏任务： -->
宏任务：每次执行栈执行的代码当作是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行），每一个宏任务会从头到尾执行完毕，不会执行其他。
常见的宏任务: 主代码块 script ；setTimeout；setInterval；setImmediate() - Node ；requestAnimationFrame() - 浏览器
当一个宏任务执行完，会在渲染前，将执行期间所产生的所有微任务都执行完
常见的微任务：Promise，process.nextTick() - Node ；Promise.then() ；catch ；finally；Object.observe；MutationObserver


页面渲染机制：宏任务 -> 微任务 -> GUI渲染 -> 宏任务 -> ...
执行一个宏任务（栈中没有就从事件队列中获取），执行过程中如果遇到微任务，就将它添加到微任务队列中，宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行），当前宏任务执行完毕，微任务执行完毕，开始检查渲染，然后GUI线程接管渲染完毕后，JS线程继续接管，开始下一个宏任务。

浏览器会先执行一个宏任务，紧接着执行当前执行栈产生的微任务，再进行渲染，然后再执行下一个宏任务。




<!-- 为什么js是单线程的？ -->
1. 历史原因。在js创建时，多进程多线程机构不流行，硬件支持差。（多线程处理需要加锁，多进程处理dom不加锁会使渲染结果不可预期）
2. 用途原因。js主要用途是与用户互动以及操作dom。多线程会带来很多复杂的同步问题
Ps：h5的Web Worker 允许js创建多个线程，但子线程完全受主线程控制，而且不得操作dom

<!-- 为什么GUI渲染线程与JS引擎线程互斥？ -->
GUI 渲染进程与js线程互斥主要是为了防止渲染不可预期的结果。如果在修改元素属性的同时渲染页面，那么渲染线程前后获得的元素就可能不一致了。

document.body.style = 'background:blue';
document.body.style = 'background:red';
document.body.style = 'background:black';

同一个宏任务，所有全部执行完才会触发页面渲染，渲染时GUI线程会将所有UI改动合并，所以视觉效果上，只会看到页面变成灰色。

document.body.style = 'background:blue';
setTimeout(()=> {document.body.style = 'background:red';})

页面会先变蓝再变红。这是因为触发了两次宏任务

document.body.style = 'background:blue';
console.log(111);
Promise.resolve().then(() => {
  console.log(222);
  document.body.style = 'background:yellow';
})
console.log(33333)

控制台输出： 1 3 2
页面背景直接变黄，没有蓝色阶段。这是因为我们再宏任务中设置蓝色，但在进行渲染前执行了微任务里的设置黄色，然后才执行的渲染。
