js执行机制：先编译，再执行。

1. JavaScript 代码执行过程中，需要先做变量提升，而之所以需要实现变量提升，是因为 JavaScript 代码在执行之前需要先编译。
2. 在编译阶段，变量和函数会被存放到变量环境中，变量的默认值会被设置为 undefined；在代码执行阶段，JavaScript 引擎会从变量环境中去查找自定义的变量和函数。
3. 如果在编译阶段，存在两个相同的函数，那么最终存放在变量环境中的是最后定义的那个，这是因为后定义的会覆盖掉之前定义的。

  showName()
  var showName = function() {
    console.log(2)
  }
  function showName() {
    console.log(1)
  }
  // 输出：1

编译与创建执行上下文：
1. 当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。
2. 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。
3. 当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。

<!-- js 调用栈 -->
1. 每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码。
2. 如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。
3. 当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。
4. 当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。

<!-- 作用域 -->
作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。
在 ES6 之前，ES 的作用域只有两种：全局作用域和函数作用域。
  1. 全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。
  2. 函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。
在 ES6 之前，JavaScript 只支持这两种作用域，相较而言，其他语言则都普遍支持块级作用域。块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个{}都可以被看作是一个块级作用域。


和 Java、C/C++ 不同，ES6 之前是不支持块级作用域的，因为当初设计这门语言的时候，并没有想到 JavaScript 会火起来，所以只是按照最简单的方式来设计。没有了块级作用域，再把作用域内部的变量统一提升无疑是最快速、最简单的设计，不过这也直接导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是 JavaScript 中的变量提升。

<!-- 块级作用域： -->
块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了。

1. 函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了。
2. 通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。
3. 在函数的作用域块内部，通过 let 声明的变量并没有被存放到词法环境中。

ps:
var的创建和初始化被提升，赋值不会被提升。
let的创建被提升，初始化和赋值不会被提升。
function的创建、初始化和赋值均会被提升。

<!-- 词法作用域与闭包 -->

词法作用域：作用域是由代码中函数声明的位置来决定的，此法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。
词法作用域是代码编译阶段就决定好的，和函数调用没有关系。词法作用域反映了代码的结构。

作用域链：通过作用域查找变量的链条称为作用域链。

闭包：在js中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量。当通过调用外部函数返回一个内部函数后，即使该外部函数已经执行结束了，内部函数引用外部函数的变量依然保存在内存中，我们把这些变量的集合称为闭包。 （ps：并不是函数嵌套函数就会产生闭包哦，还是要根据词法作用域判断内部函数是否访问的是外层函数作用域的变量，具体可参考下面例子👇）

var bar = {
  myName:"time.geekbang.com",
  printName: function () {
    console.log(myName)
  }    
}
function foo() {
  let myName = " 极客时间 "
  return bar.printName
}
let myName = " 哈哈哈 "
let _printName = foo()
_printName()
bar.printName()

// 输出： 哈哈哈 哈哈哈
// 解析：
1. bar 不是一个函数，因此 bar 当中的 printName 其实是一个全局声明的函数，bar 当中的 myName 只是对象的一个属性，也和 printName 没有联系，如果要产生联系，需要使用 this 关键字，表示这里的 myName 是对象的一个属性，不然的话，printName 会通过词法作用域链去到其声明的环境，也就是全局，去找 myName
2. foo 函数返回的 printName 是全局声明的函数，因此和 foo 当中定义的变量也没有任何联系，这个时候 foo 函数返回 printName 并不会产生闭包


闭包回收：如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭，但如果这个闭包以后不再使用就会造成内存泄漏。如果闭包函数式一个局部变量，那么函数销毁后，在下次js引擎执行垃圾回收时，判断闭包这块内容若不再使用，就会被回收掉。

闭包使用原则：如果闭包会一直使用，那么它可以作为一个全局变量存在，如果使用频率不高，而且占内存较大，那就尽量变为一个局部变量。


<!-- this指向 -->
全局执行上下文中的this：指向window对象
函数执行上下文中的this：
1. 使用call、apply、bind设置
2. 通过对象调用方法设置:
  (1)使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的
    var myObj = {
      name : "极客时间", 
      showThis: function(){
        console.log(this)
      }
    }
    myObj.showThis()
    // 输出：myObj

  (2)在全局环境中调用一个函数，函数内部的 this 指向的是全局变量 window。通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 this 指向对象本身。
    var myObj = {
      name : "极客时间",
      showThis: function(){
        this.name = "极客邦"
        console.log(this)
      }
    }
    var foo = myObj.showThis
    foo()
  // 输出：window

3. 通过构造函数设置


<!-- this 缺陷与解决 -->
1. 嵌套函数中的 this 不会从外层函数中继承
  解决：使用一个变量来保存this或使用箭头函数
2. 普通函数中的 this 默认指向全局对象 window
解决：使用call方法显示调用

