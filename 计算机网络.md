 
<!-- 即时通信方案 -->
即时通信方案：两个客户机能够同时收发消息
方案：
1. 短轮询：前端定时请求ajax更新数据
2. 长轮询：请求到服务端后就被挂起，直到有新的消息才会返回响应
3. 基于流（SSE)：SSE 是h5的属性，它只能由服务器向浏览器发送数据，所以协作是通过http发送消息，sse接受消息
4. websocket：websocket 是h5提供的一种在单个tcp连接上进行的全双工通信协议（钉钉表格就是用的原生websocket）
5. socket.io：socket.io 是为了解决websocket的兼容性的一个解决方案，websocket对老浏览器兼容性不好。socket.io 将websocket、长轮询两种
   通信方式封装成了统一的通信接口进行降级兼容

<!-- 单工、半双工和全双工通信 -->
单工通信：消息只能单方向传输的工作方式，数据从一端到另一端是单方向的。例如：广播
半双工通信：可以实现双向的通信，但是不能在两个方向同时进行，必须交替进行。这种模式下，接收端和发送端可以相互转换。例如：对讲机
全双工通信：在通信的任何时刻，都允许数据同时在两个方向上传输，在这个模式下，通信系统的每一端都设置了发送器和接收器


<!-- 七层协议 -->
各层基本作用：
  应用层：为应用程序提供网络服务；
  表示层：数据格式化、加密、解密；
  会话层：建立、维护、管理会话连接；
  传输层：建立、维护、管理到端连接；
  网络层：IP寻址和路由选择；
  数据链路层：控制网络层与物理层之间通信；
  物理层：通过光缆、无线电波等方式连接组网；传输比特流0和1；

<!-- 网络层IP寻址和路由： -->
寻址就是根据ip地址找到具体的设备。
  ipv4 的网络是一个树状模型，顶层网络下方有多个子网，子网下方还有子网，最后才是设备。IP协议的寻址过程就是要逐级找到网络，最后定位设备。
路由就是选择数据传输的线路
  在寻址过程中，数据总是存在于某个局域网中。如果目的地在局域网中，就可以直接定位到设备了，但如果目的地不在局域网中，这个时候就需要再去往其他网络；
  由于网络和网络之间是网关在连接，所以如果目的地ip不在局域网中，就要为ip封包选择通往下一个网络的路径，也就是其中一个网关；
  当包去往下一个节点后，就进入了新的路由节点，然后就继续上述过程，直到最终定位到设备
网络层就是通过IP寻址找到最终的设备，又要借助路由在每个节点选择数据传输的线路，所以路由和寻址是相辅相成的关系

<!-- HTTP 与 WebSocket -->
相同点：都是一样基于TCP的应用层协议，都是可靠性传输协议。
不同点：
  1. WebSocket 是全双工通信协议，通信双方可以实时且同时发送和接收消息。而HTTP是单向的；
  2. WebSocket 没有了 Request 和 Response 的概念
  3. WebSocket 需要依赖 HTTP 协议进行一次握手。握手成功过后数据就直接从 TCP 通道传输，与 HTTP 无关；
  4. WebSocket 数据格式比较轻量，它的数据包头部较小，而HTTP协议每次通信都需要携带完整的头部
  5. WebSocket 无跨域问题

<!-- WebSocket 握手协议 与 Http握手 的区别 -->
WebSocket 的握手协议相比 Http原本的握手协议 ，多了两个属性：Upgrade:webSocket和 Connection:Upgrade
客户端发送的握手协议，带有两个额外的属性，服务端就会返回101状态码，客户端收到101状态码后就成功

<!-- DNS 的作用 -->
DNS 的作用就是通过域名查询到具体的 IP。是应用层协议，通常该协议运行在UDP协议之上，使用的是53端口号。
<!-- DNS 查询流程 -->
以 Chrome 为例，当你在浏览器中想访问 www.google.com 时，会通过进行以下操作：
  Chrome 先查看浏览器自身有没有该域名的 IP 缓存
  Chrome 再查看操作系统有没有该域名的 IP 缓存
  Chrome 再查看 Host 文件有没有该域名的解析配置

如果在hosts文件中也没有找到对应的条目，浏览器就会请求本地域名服务器localDNS（LDNS）来解析这个域名。（这是递归查询的流程）

如果 LDNS 也没有该域名的记录，就会进行迭代查询：
LDNS 先去 DNS根域名服务器查询，这一步查询会找出负责 com 这个一级域名的服务器
LDNS 再去该服务器查询 google.com 这个二级域名
LDNS 再去查询 www.google.com 这个三级域名的地址
LDNS 返回给浏览器，并缓存起来

<!-- 递归查询 和 迭代查询 -->

递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归查询，用户只需要发出一次查询请求。
迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。
所以一般而言，本地DNS服务器查询是递归查询，而本地DNS服务器向其他域名服务器请求的过程是迭代查询的过程

<!-- DNS 实现负载平衡 -->
某些大型网站一般都会使用多台服务器提供服务，因此一个域名可能对应多个服务器地址；
当用户发起网站域名的 DNS 请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合
在每个响应中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。
以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。
还有一种负载均衡的方式，使用反向代理，用户的请求都发送到反向代理服务上，然后由反向代理服务器来转发请求到真实的服务器上，以此来实现集群的负载平衡。

<!-- DNS 为什么选择 UDP 协议作为传输层协议 -->
为了得到一个域名的 IP 地址，往往会向多个域名服务器查询，而TCP协议存在三次握手，会造成DNS服务变得很慢

<!-- 队头阻塞问题 -->
队头阻塞是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞
  <!-- TCP 队头阻塞 -->
  TCP是可靠传输协议，当前一个数据丢失时，后面到的数据将在接收端等待到前一个丢失的数据被发送端重传并到达接收端为止
  这种机制保证了数据的有序正确，但也有可能造成 TCP队头阻塞；
  <!-- HTTP 队头阻塞 -->
  HTTP1.1 允许在持久连接上可选的使用请求管道
  管道允许客户端在已发送请求后就发送下一个请求，不需要等待前一个请求响应，借此来减少等待时间；
  但是客户端要求服务端按照请求发送的顺序返回响应，原因很简单：HTTP请求和响应并没有序列号标识，无法将乱序的响应与请求关联起来；
  也就意味着如果一个响应返回延迟了，那么后续的响应都会延迟；这 就造成了 HTTP队头阻塞；

  解决方法：
    TCP队头阻塞问题是 TCP 自身的机制决定的，无法避免，所以 google 才推出 QUIC协议，也就是所谓的 HTTP3；
    HTTP2 使用帧和流来传输数据，因为流的概念是虚拟的，所以HTTP2可以在一个TCP连接上用流同时发送多个帧，也就是所谓的多路复用：多个请求都复用一个连接来处理；
    在流的层面上看，同个流的帧是严格有序的，而从连接的层面上看，传输的都是乱序的帧；多个请求、响应之间没有的顺序关系；也就不需要排队等待，避免了队头阻塞的问题；

  简单来说：就是HTTP2通过帧、流、多路复用的方式，让请求和响应不用按顺序一一对应，解决队头阻塞的问题；
  对于 HTTP1来说，可以使用 并发连接 和 域名分片 来一定程度上解决问题，chrome对单域名 限制并发6个TCP持久连接；而域名分片我们可以在一个域名下分出多个二级域名，而它们最终指向同一个服务器，这样可以并发的数量就更多；

<!-- http1.0/ http1.1 /http2.0/http3.0 区别 -->
HTTP 1.0:
  http1.0只支持POT/GET/HEAD命令
  不支持断点续传，也就是说，每次都会传送全部的页面和数据。
  只使用 header 中的Last-Modified、If-Modified-Since（协商缓存） 和 Expires（强缓存） 作为缓存失效的标准。
HTTP 1.1:
  1. 引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive；
  2. 引入了管道机制，即在同一个TCP连接里，客户端不用等待请求响应就可以发送多个请求，但要求服务端要按发送顺序返回；
  3. 支持断点续传，通过使用请求头中的 Range 来实现（206状态码）。
  4. HTTP 1.1 中新增加了 E-tag、If-None-Match、Cache-Control 等缓存控制标头来控制缓存失效。
  5. 使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。
  6. 新增方法：PUT、 OPTIONS、 DELETE等。
  7. 更多的缓存标识：Cache-Control、ETag、If-None-Match

  缺点：
  1. 由于队头阻塞带来的高延迟
  2. 巨大的http头部
  3. 不支持服务器推送消息

HTTP 2.0：
  二进制分帧：在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP/2 中信息和数据体都是二进制，并且统称为"帧"：用头信息帧放头部字段，用数据帧放请求数据体，是一堆乱序的二进制帧，它们不存在先后关系，因此不需要排队等待，是HTTP2多路复用的基础。
  头部压缩：HTTP2使用 HPACK算法 压缩头部然后再发送，并在两端维护了索引表，用于记录出现过的 header，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。
  多路复用：在一个连接里，可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了HTTP队头阻塞的问题。
  服务器推送：允许浏览器发送一个请求后，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求去获取一些资源。但是Chrome106版本禁用了，改为103状态码；

  服务器推送时，客户端的特点：
  1. 客户端可以缓存推送的资源
  2. 客户端可以拒收推送过来的资源
  3. 服务器可以按照优先级推送资源

HTTP 3.0：
  Google搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上
  HTTP3 出现原因 & HTTP2 缺点：
  1. 底层协议还是TCP，仍然需要三次握手来确认连接成功，
  2. TCP的队头阻塞并没有彻底解决，在 HTTP2 中，多个请求是跑在一个TCP连接中的。但当HTTP/2出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该TCP连接中的所有请求。

  QUIC：
  1. 实现了快速握手功能。由于QUIC是基于UDP的，不需要三次握手，这意味着QUIC可以用最快的速度来发送和接收数据。（3RTT => 0/1 RTT；根据是否要TLS加密）
  2. 实现了类似TCP的可靠传输，虽然UDP不提供可靠性的传输，但QUIC在UDP的基础之上增加了一层来保证数据可靠性传输。（用的ACK模式，只是QUIC中包丢了就丢了，会重传一个新序号的包，通过包内的offset字段来确定这个包的位置）
  3. 集成了 TLS 加密功能，目前QUIC使用的是TLS1.3，相较于早期版本TLS1.3有更多的优点，其中最重要的一点是减少了握手所花费的RTT个数。
  4. 同样也提供了拥塞控制机制，包括慢启动、拥塞避免等；
  5. 也实现了多路复用，每个请求会在 quic 层面定义为一个 stream，丢包也只影响当前stream；彻底解决 TCP 中队头阻塞的问题
