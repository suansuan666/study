 
<!-- 即时通信方案 -->
即时通信方案：两个客户机能够同时收发消息
方案：
1. 短轮询：前端定时请求ajax更新数据
2. 长轮询：请求到服务端后就被挂起，直到有新的消息才会返回响应
3. 基于流（SSE)：SSE 是h5的属性，它只能由服务器向浏览器发送数据，所以协作是通过http发送消息，sse接受消息
4. websocket：websocket 是h5提供的一种在单个tcp连接上进行的全双工通信协议（钉钉表格就是用的原生websocket）
5. socket.io：socket.io 是为了解决websocket的兼容性的一个解决方案，websocket对老浏览器兼容性不好。socket.io 将websocket、长轮询两种
   通信方式封装成了统一的通信接口jin xing1降级兼容

<!-- 单工、半双工和全双工通信 -->
单工通信：消息只能单方向传输的工作方式，数据从一端到另一端是单方向的。例如：广播
半双工通信：可以实现双向的通信，但是不能在两个方向同时进行，必须交替进行。这种模式下，接收端和发送端可以相互转换。例如：对讲机
全双工通信：在通信的任何时刻，都允许数据同时在两个方向上传输，在这个模式下，通信系统的每一端都设置了发送器和接收器


<!-- 七层协议 -->
各层基本作用：
  应用层：为应用程序提供网络服务；
  表示层：数据格式化、加密、解密；
  会话层：建立、维护、管理会话连接；
  传输层：建立、维护、管理到端连接；
  网络层：IP寻址和路由选择；
  数据链路层：控制网络层与物理层之间通信；
  物理层：通过光缆、无线电波等方式连接组网；传输比特流0和1；

<!-- 网络层IP寻址和路由： -->
寻址就是根据ip地址找到具体的设备。
  ipv4 的网络是一个树状模型，顶层网络下方有多个子网，子网下方还有子网，最后才是设备。IP协议的寻址过程就是要逐级找到网络，最后定位设备。
路由就是选择数据传输的线路
  在寻址过程中，数据总是存在于某个局域网中。如果目的地在局域网中，就可以直接定位到设备了，但如果目的地不在局域网中，这个时候就需要再去往其他网络；
  由于网络和网络之间是网关在连接，所以如果目的地ip不在局域网中，就要为ip封包选择通往下一个网络的路径，也就是其中一个网关；
  当包去往下一个节点后，就进入了新的路由节点，然后就继续上述过程，直到最终定位到设备
网络层就是通过IP寻址找到最终的设备，又要借助路由在每个节点选择数据传输的线路，所以路由和寻址是相辅相成的关系

<!-- HTTP 与 WebSocket -->
相同点：都是一样基于TCP的应用层协议，都是可靠性传输协议。
不同点：
  1. WebSocket 是全双工通信协议，通信双方可以实时且同时发送和接收消息。而HTTP是单向的；
  2. WebSocket 没有了 Request 和 Response 的概念
  3. WebSocket 需要依赖 HTTP 协议进行一次握手。握手成功过后数据就直接从 TCP 通道传输，与 HTTP 无关；
  4. WebSocket 数据格式比较轻量，它的据包头部较小，而HTTP协议每次通信都需要携带完整的头部
  5. WebSocket 无跨域问题

<!-- WebSocket 握手协议 与 Http握手 的区别 -->
WebSocket 的握手协议相比 Http原本的握手协议 ，多了两个属性：Upgrade:webSocket和 Connection:Upgrade
客户端发送的握手协议，带有两个额外的属性，服务端就会返回101状态码，客户端收到101状态码后就成功

<!-- DNS 的作用 -->
DNS 的作用就是通过域名查询到具体的 IP。是应用层协议，通常该协议运行在UDP协议之上，使用的是53端口号。
<!-- DNS 查询流程 -->
以 Chrome 为例，当你在浏览器中想访问 www.google.com 时，会通过进行以下操作：
  Chrome 先查看浏览器自身有没有该域名的 IP 缓存
  Chrome 再查看操作系统有没有该域名的 IP 缓存
  Chrome 再查看 Host 文件有没有该域名的解析配置

如果在hosts文件中也没有找到对应的条目，浏览器就会请求本地域名服务器localDNS（LDNS）来解析这个域名。（这是递归查询的流程）

如果 LDNS 也没有该域名的记录，就会进行迭代查询：
LDNS 先去 DNS根域名服务器查询，这一步查询会找出负责 com 这个一级域名的服务器
LDNS 再去该服务器查询 google.com 这个二级域名
LDNS 再去查询 www.google.com 这个三级域名的地址
LDNS 返回给浏览器，并缓存起来

<!-- 递归查询 和 迭代查询 -->

递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归查询，用户只需要发出一次查询请求。
迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。
所以一般而言，本地DNS服务器查询是递归查询，而本地DNS服务器向其他域名服务器请求的过程是迭代查询的过程

<!-- DNS 实现负载平衡 -->
某些大型网站一般都会使用多台服务器提供服务，因此一个域名可能对应多个服务器地址；
当用户发起网站域名的 DNS 请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合
在每个响应中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。
以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。
还有一种负载均衡的方式，使用反向代理，用户的请求都发送到反向代理服务上，然后由反向代理服务器来转发请求到真实的服务器上，以此来实现集群的负载平衡。

<!-- DNS 为什么选择 UDP 协议作为传输层协议 -->
为了得到一个域名的 IP 地址，往往会向多个域名服务器查询，而TCP协议存在三次握手，会造成DNS服务变得很慢

<!-- 队头阻塞问题 -->
队头阻塞是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞
  <!-- TCP 队头阻塞 -->
  TCP是可靠传输协议，当前一个数据丢失时，后面到的数据将在接收端等待到前一个丢失的数据被发送端重传并到达接收端为止
  这种机制保证了数据的有序正确，但也有可能造成 TCP队头阻塞；
  <!-- HTTP 队头阻塞 -->
  HTTP1.1 允许在持久连接上可选的使用请求管道
  管道允许客户端在已发送请求后就发送下一个请求，不需要等待前一个请求响应，借此来减少等待时间；
  但是客户端要求服务端按照请求发送的顺序返回响应，原因很简单：HTTP请求和响应并没有序列号标识，无法将乱序的响应与请求关联起来；
  也就意味着如果一个响应返回延迟了，那么后续的响应都会延迟；这就造成了 HTTP队头阻塞；

  解决方法：
    TCP队头阻塞问题是 TCP 自身的机制决定的，无法避免，所以 google 才推出 QUIC协议，也就是所谓的 HTTP3；
    HTTP2使用帧和流来传输数据，因为流的概念是虚拟的，所以HTTP2可以在一个TCP连接上用流同时发送多个帧，也就是所谓的多路复用：多个请求都复用一个连接来处理；
    在流的层面上看，同个流的帧是严格有序的，而从连接的层面上看，传输的都是乱序的帧；多个请求、响应之间没有的顺序关系；也就不需要排队等待，避免了队头阻塞的问题；

  简单来说：就是HTTP2通过帧、流、多路复用的方式，让请求和响应不用按顺序一一对应，解决队头阻塞的问题；
  对于 HTTP1来说，可以使用 并发连接 和 域名分片 来一定程度上解决问题，chrome对单域名 限制并发6个TCP持久连接；而域名分片我们可以在一个域名下分出多个二级域名，而它们最终指向同一个服务器，这样可以并发的数量就更多；

。