<!-- 执行栈、宏任务、微任务、渲染任务、requestAnimationFrame以及requestIdleCallback执行顺序？ -->
执行栈 -》执行所有的微任务 -》check render检查是否需要渲染（达到浏览器的该渲染的帧率）-》需要渲染：执行requestAniamtionFrame -> 需要渲染：阻塞js引擎线程，切到渲染线程执行 -》check worker 检查是否有worker任务 -》离渲染还有时间，或timeout时间到了执行requesetIdleCallback

js引擎线程和渲染线程同一时刻只能有一个被执行
UI rendering：浏览器会根据当前设备的刷新率登因素设置一个帧率（比如：1s60帧）来决定何时运行（在js不阻塞的情况下），包括：dom操作、css3动画效果（暂认为在每次eventLoop的微任务队列清空完之后统一分析后执行渲染）


<!-- 浏览器安全 -->
xss: 跨站脚本攻击。指攻击者在返回的html中嵌入js脚本，从而拿到用户信息并操作。
xss种类：存储型、反射型、文档型

常见场景：评论区提交一段代码，若前后端没有做好转义，存储到数据库后，在客户端渲染时就直接执行了

反射型：恶意脚本作为请求url的参数，浏览器解析后作为脚本执行。
ps:之所以叫它反射型是因为恶意脚本是通过作为网络请求参数出现url上的，经过服务器解析并拼接在html中回传给客户端）
和存储型的区别：服务器不会存储这些恶意脚本

文档型：也是作为请求url的参数，浏览器解析后作为脚本执行
与反射型的区别：由前端js取出url中的恶意代码并执行

对于xss的防范：
1. 转义和过滤。对引号、尖括号、斜杠等进行转义，让代码在html解析的过程中无法执行。过滤就是把script标签删掉
2. 利用httpOnly。cookie设置httpOnly后，会禁止js脚本获取 cookie。
3. csp。csp是浏览器安全策略，只允许加载指定域的脚本和样式

CSRF：跨站请求伪造。指诱导用户跳转恶意网站，然后利用用户的登录态发起恶意请求。
原理：http请求会自动携带cookie，而且是http目标请求域名的cookie

对于CSRF的防范：
1. samesite cookies：该属性表示cookie不随跨域请求发送。他有strict（浏览器只发送相同站点请求的cookie）、Lax（第三方get方法可以携带 cookie）和None（任何情况都会发送 cookie）这三个值。
2. origin 和 referer：验证referer是否是从第三方网站发出来的，阻止第三方网站请求接口（但是这两者可以通过ajax自定义请求头的方式被伪造）
3. CSRF Token：客户端向服务端请求token，然后在所有的请求中带上

SQL注入：把sql命令插入到web表单、页面请求的查询字符串里面提交到服务器，最终达到欺骗服务器执行恶意的sql命令
原理：服务端在执行sql操作时，可能会拼接前端传入的参数，这就会将sql注入的sql拼接起来，导致一些预期之外的操作
防范：
1. 对用户的输入进行校验，通过正则或限制长度等方式对“#”和"--"字符进行转换等
2. 不使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取
3. 不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接
4. 不要把机密信息明文存放，请加密或hash掉密码和敏感的信息

点击劫持：是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过iframe嵌套的方式嵌入自己的网页中，并将iframe设置为透明，在页面中透出一个按钮诱导用户点击。
防范：
设置x-frame-options响应头。该响应头有三个值，分别是：
1. deny：表示页面不允许通过 iframe的方式展示
2. sameorigin: 表示页面可以在相同域名下通过 iframe的方式显示
3. allow-from：表示页面可以在指定来源的iframe中展示

<!-- 预加载和预连接 -->
预加载：
<link href="/js/xx.js" rel="prefetch">
prefetch: 利用浏览器空闲时间下载用户在不久以后可能访问的资源（比如：下一个页面）
加载完成以后，浏览器在使用资源时自动从prefetch cache读取资源

<link href="/js/xxx.js" rel="preload" as="script">
preload: 可指明哪些资源在页面加载完成后需要的，这一机制使得资源可以更早的得到加载并可用，且不易阻塞页面的初步渲染，进而提升性能
需要 as 指定资源类型，比如font字体文件、style样式表；

preload、prefetch仅仅是加载资源，并不会执行；
preload、prefetch均能设置、命中缓存；

预连接：
preconnect: 在下载资源时，要先建立连接，再下载资源。建立连接时会涉及到dns寻址、tls握手、tcp握手、重定向等步骤
使用preconnect后，浏览器会提前做好连接工作，但只保留10s，之后就会被关闭；不必要的预连接会延迟其他资源，因此要限制preconnect 预连接的数量
使用场景：资源后缀是动态的，还不确定资源具体的地址时；页面上有媒体，但没那么快播放，又希望点击时尽快播放

dns-prefetch和preconnect的区别：
1. dns-prefetch 可以预先解析dns，只对跨域的dns查找有效
2. preconnect 的浏览器兼容性稍微差一点
3. dns-prefetch 只能预先进行到dns查询这一步



<!-- 复杂请求 -->
复杂请求的cors请求会在正式通信之前增加一次http查询，称为预检请求，请求的方法是option，通过该请求来查询服务端是否允许跨域请求。
option 请求头里有一个Access-Control-Request-Method 字段，表示在实际发出请求时将用什么请求方法。
Access-Control-Request-Method 作用：
1. 该请求头在发出预检请求时，让服务器知道在发出世纪请求时将使用哪种请求方式
2. 此标头必需，因为预检请求始终时一个options，与实际请求不是相同方法



<!-- 浏览器是多进程的优点 -->
1. 默认新开一个tab页面新建一个进程，所以单个tab页面崩溃不会影响到整个浏览器
2. 第三方插件崩溃不会影响到整个浏览器
3. 多进程可以充分利用现代cpu多核的优势


<!-- 进程间通讯的方式 -->
信号：信号是进程间通信唯一的异步通信机制，因为可以在任何时候发送信号给某一个进程
匿名管道：是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程在缓冲区的末尾写数据，管道另一端的进程在缓冲区的头部读数据；只能用于父子关系的进程
命名管道：正常的匿名管道需要父子关系，而命名管道提供了一个路径名与之相连，从而以文件的形式存在于文件系统中；不受父子关系限制
消息队列：消息队列本质时保存在内核当中的消息链表
共享内存：共享内存可以使得多个进程之间可以直接读写在同一块内存空间中，这是效率最高的进程间通信方式
socket：socket可以让跨网络的不同主机之间进行通讯，还可以在同主机上进程间通讯


<!-- 跨页签通信 & 多tab通信 -->
1. 设置同域下共享的localStorage 与绑定监听window.addEventListner('storage') 
(重复写入相同的值无法触发；会收到浏览器隐身模式等的限制)
2. websocket 配合服务端
3. service worker
4. indexedDB 浏览器数据库实现，共享存储+轮询的方式
5. 通过父页面window.open()和子页面postMessage